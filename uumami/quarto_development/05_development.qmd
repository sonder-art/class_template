---
title: "Development Guide"
subtitle: "Extending & Customizing the System"
format:
  html:
    css:
      - ../../quarto_code/styles/main.css
      - ../../quarto_code/styles/themes/evangelion.css
    toc: true
---

# Development Guide

> **ðŸš€ Advanced Customization**  
> Learn how to extend, modify, and customize the automation system for specific needs, institutional requirements, and advanced use cases.

## Development Environment Setup

### Prerequisites

**Required Tools**:
```bash
# Core requirements
python3 --version          # 3.8+
quarto --version           # 1.3+
git --version              # 2.0+

# Development tools (recommended)
pip install black flake8 mypy pytest
```

**Project Structure Understanding**:
```
uumami/quarto_code/
â”œâ”€â”€ scripts/              # ðŸŽ¯ Main development area
â”‚   â”œâ”€â”€ scan_structure.py
â”‚   â”œâ”€â”€ validate_structure.py
â”‚   â””â”€â”€ generate_navigation.py
â”œâ”€â”€ components/           # UI components
â”œâ”€â”€ styles/              # Theming system
â”œâ”€â”€ _extensions/         # Quarto extensions
â””â”€â”€ templates/           # Future: Content templates
```

### Development Workflow

**1. Setup Development Environment**:
```bash
# Create development branch
git checkout -b feature/custom-enhancement

# Install development dependencies
pip install -r uumami/requirements.txt
pip install black flake8 mypy pytest

# Test baseline functionality
python3 uumami/quarto_code/scripts/scan_structure.py uumami/ --validate
```

**2. Development Best Practices**:
```bash
# Code formatting
black uumami/quarto_code/scripts/

# Linting
flake8 uumami/quarto_code/scripts/

# Type checking
mypy uumami/quarto_code/scripts/
```

## Extension Points

### 1. Adding Custom Validation Rules

**File**: `uumami/quarto_code/scripts/validate_structure.py`

**Location to Modify**:
```python
class StructureValidator:
    def validate_structure(self, structure_data: Dict[str, Any]) -> bool:
        """Run comprehensive structure validation."""
        self.issues.clear()
        
        # Existing validations
        self.validate_naming_conventions(structure_data)
        self.validate_required_files(structure_data)
        self.validate_yaml_frontmatter(structure_data)
        self.validate_file_organization(structure_data)
        
        # ðŸŽ¯ ADD YOUR CUSTOM VALIDATIONS HERE
        self.validate_custom_requirements(structure_data)
        
        # Return True if no errors
        errors = [issue for issue in self.issues if issue.level == ValidationLevel.ERROR]
        return len(errors) == 0
```

**Example Custom Validation**:
```python
def validate_custom_requirements(self, structure_data: Dict[str, Any]) -> None:
    """Custom validation rules for your institution."""
    
    # Example: Ensure all chapters have learning objectives
    for chapter in structure_data.get('chapters', []):
        chapter_path = Path(chapter['path'])
        
        # Check for objectives file
        objectives_file = chapter_path / 'learning_objectives.md'
        if not objectives_file.exists():
            self.add_issue(
                ValidationLevel.WARNING,
                "Educational Standards",
                f"Missing learning objectives in {chapter['name']}",
                str(chapter_path),
                f"Create file: learning_objectives.md",
                "missing_objectives"
            )
        
        # Example: Ensure sections follow your numbering scheme
        for section in chapter.get('sections', []):
            if section['type'] == 'directory':
                section_path = Path(section['path'])
                readme_file = section_path / 'README.md'
                if not readme_file.exists():
                    self.add_issue(
                        ValidationLevel.INFO,
                        "Documentation",
                        f"Consider adding README.md to {section['name']}",
                        str(section_path),
                        "Add section overview documentation",
                        "missing_section_readme"
                    )
```

### 2. Customizing Navigation Generation

**File**: `uumami/quarto_code/scripts/generate_navigation.py`

**Customization Points**:

**A. Modify Menu Structure**:
```python
def generate_course_menu(self, structure_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Generate the course menu with chapters and sections."""
    menu_items = []
    
    # ðŸŽ¯ CUSTOMIZE: Add institutional branding
    menu_items.append({
        'text': 'ðŸ›ï¸ Institution Name',
        'href': 'https://your-institution.edu'
    })
    
    # ðŸŽ¯ CUSTOMIZE: Group chapters by topic
    topic_groups = self.group_chapters_by_topic(structure_data['chapters'])
    for topic, chapters in topic_groups.items():
        topic_menu = {
            'text': f'ðŸ“š {topic}',
            'menu': []
        }
        
        for chapter in chapters:
            topic_menu['menu'].append({
                'text': f"{chapter['prefix']}. {chapter['title']}",
                'href': f"notas/{chapter['name']}/{chapter['index_file']}"
            })
        
        menu_items.append(topic_menu)
    
    return menu_items

def group_chapters_by_topic(self, chapters: List[Dict[str, Any]]) -> Dict[str, List]:
    """Custom logic to group chapters by educational topics."""
    groups = {'Fundamentals': [], 'Advanced': [], 'Projects': []}
    
    for chapter in chapters:
        # Custom logic based on your naming or metadata
        if 'fundamental' in chapter['title'].lower():
            groups['Fundamentals'].append(chapter)
        elif 'project' in chapter['title'].lower():
            groups['Projects'].append(chapter)
        else:
            groups['Advanced'].append(chapter)
    
    return {k: v for k, v in groups.items() if v}  # Remove empty groups
```

**B. Add Custom Navigation Elements**:
```python
def generate_navbar_structure(self, structure_data: Dict[str, Any], 
                            original_config: Dict[str, Any]) -> Dict[str, Any]:
    """Generate complete navbar structure from content discovery data."""
    
    # Preserve existing navbar elements
    preserved_elements = self.preserve_navbar_elements(original_config)
    
    # Build left-side navigation
    left_nav = [
        {'href': 'index.qmd', 'text': 'Class Notes'},
        {'href': 'syllabus.qmd', 'text': 'Syllabus'},
        {'href': 'schedule.qmd', 'text': 'Schedule'}
    ]
    
    # ðŸŽ¯ ADD: Custom institutional elements
    left_nav.append({
        'text': 'ðŸ“‹ Resources',
        'menu': [
            {'text': 'Library Resources', 'href': 'https://library.institution.edu'},
            {'text': 'Writing Center', 'href': 'https://writing.institution.edu'},
            {'text': 'Tech Support', 'href': 'https://tech.institution.edu'}
        ]
    })
    
    # Standard course content
    course_menu = self.generate_course_menu(structure_data)
    if course_menu:
        left_nav.append({
            'text': 'ðŸ“š Course',
            'menu': course_menu
        })
    
    # Rest of navbar generation...
```

### 3. Adding New Automation Scripts

**Template for New Script**:

Create `uumami/quarto_code/scripts/your_script.py`:

```python
#!/usr/bin/env python3
"""
Your Custom Automation Script

Description of what this script does and how it integrates
with the existing automation system.
"""

import sys
from pathlib import Path
from typing import Dict, List, Optional, Any
import click
from rich.console import Console

# Import existing functionality
try:
    from scan_structure import scan_content_structure
    from validate_structure import StructureValidator
except ImportError:
    sys.path.append(str(Path(__file__).parent))
    from scan_structure import scan_content_structure
    from validate_structure import StructureValidator

console = Console()

class YourCustomAutomation:
    """Your custom automation logic."""
    
    def __init__(self, base_path: Path):
        self.base_path = base_path
        # Initialize your custom logic
    
    def process_content(self, structure_data: Dict[str, Any]) -> bool:
        """Your main processing logic."""
        try:
            # Your custom automation here
            console.print("[green]âœ… Custom processing completed![/green]")
            return True
        except Exception as e:
            console.print(f"[red]âŒ Custom processing failed:[/red] {e}")
            return False

@click.command()
@click.argument('path', type=click.Path(exists=True, path_type=Path))
@click.option('--verbose', '-v', is_flag=True, help='Verbose output')
@click.option('--dry-run', is_flag=True, help='Preview changes only')
def main(path: Path, verbose: bool, dry_run: bool):
    """
    Your Custom Automation Script
    
    PATH: Base directory to process (typically 'uumami/')
    """
    
    try:
        # Use existing infrastructure
        with console.status("[bold green]Scanning content structure..."):
            structure_data = scan_content_structure(path)
        
        if verbose:
            console.print(f"[dim]ðŸ“– Found {len(structure_data['chapters'])} chapters[/dim]")
        
        # Validate first (good practice)
        validator = StructureValidator()
        if not validator.validate_structure(structure_data):
            console.print("[red]âŒ Structure validation failed. Fix issues first.[/red]")
            sys.exit(1)
        
        # Your custom processing
        automation = YourCustomAutomation(path)
        
        if dry_run:
            console.print("[yellow]ðŸ“‹ Dry run mode - preview only[/yellow]")
            # Show what would be done
        else:
            success = automation.process_content(structure_data)
            if not success:
                sys.exit(1)
        
        console.print("[green]ðŸŽ‰ Custom automation completed![/green]")
        
    except Exception as e:
        console.print(f"[bold red]âŒ Error:[/bold red] {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
```

### 4. Custom Content Discovery

**Extending Content Types**:

In `scan_structure.py`, modify the discovery patterns:

```python
# Add custom content types
NAMING_PATTERNS = {
    'chapter': r'^\d{2}_[\w_]+$',
    'appendix': r'^[a-z]_[\w_]+$',
    'section_file': r'^\d{2}_[\w_]+\.qmd$',
    'index_file': r'^\d{2}_index\.qmd$',
    'section_dir': r'^[a-z]_[\w_]+$',
    'nav_file': r'^_nav\.qmd$',
    
    # ðŸŽ¯ ADD: Custom patterns
    'project_dir': r'^project_[\w_]+$',        # project_final, project_midterm
    'resource_file': r'^resource_[\w_]+\.qmd$', # resource_guide.qmd
    'exercise_file': r'^ex_\d{2}_[\w_]+\.qmd$'  # ex_01_basics.qmd
}

def scan_custom_content(self, base_path: Path) -> Dict[str, Any]:
    """Discover custom content types."""
    custom_content = {
        'projects': [],
        'resources': [],
        'exercises': []
    }
    
    for item in base_path.rglob('*'):
        if item.is_dir() and re.match(NAMING_PATTERNS['project_dir'], item.name):
            custom_content['projects'].append({
                'name': item.name,
                'path': str(item),
                'type': 'project'
            })
        # Add more custom discovery logic...
    
    return custom_content
```

## Integration Patterns

### Script Communication

**Shared Data Format**:
```python
# Standard structure data format for all scripts
STRUCTURE_DATA_SCHEMA = {
    "scan_timestamp": "ISO datetime",
    "base_path": "string",
    "content_path": "string", 
    "chapters": [
        {
            "name": "string",
            "prefix": "string",
            "title": "string",
            "path": "string",
            "has_index": "boolean",
            "index_file": "string|null",
            "sections": []
        }
    ],
    "appendices": [],
    "stats": {},
    # ðŸŽ¯ ADD: Your custom data
    "custom_content": {}
}
```

**Script Chaining Pattern**:
```python
def create_automation_pipeline(base_path: Path) -> bool:
    """Example of chaining multiple automation scripts."""
    
    # 1. Discovery
    structure_data = scan_content_structure(base_path)
    
    # 2. Validation
    validator = StructureValidator()
    if not validator.validate_structure(structure_data):
        console.print("Fix validation issues first")
        return False
    
    # 3. Custom processing
    custom_processor = YourCustomAutomation(base_path)
    custom_processor.process_content(structure_data)
    
    # 4. Navigation generation
    nav_generator = NavigationGenerator(base_path)
    nav_generator.generate_navigation(structure_data)
    
    return True
```

### Configuration Management

**Custom Configuration**:
```python
# Create custom config file: uumami/automation_config.yml
CUSTOM_CONFIG = """
automation:
  validation:
    strict_mode: true
    custom_rules: 
      - learning_objectives_required
      - section_readme_recommended
  
  navigation:
    group_by_topic: true
    institutional_links: true
    max_menu_depth: 3
  
  content_types:
    projects: true
    exercises: true
    resources: true

institution:
  name: "Your Institution"
  library_url: "https://library.institution.edu"
  support_email: "support@institution.edu"
"""

def load_custom_config(base_path: Path) -> Dict[str, Any]:
    """Load custom configuration."""
    config_file = base_path / 'automation_config.yml'
    if config_file.exists():
        with open(config_file, 'r') as f:
            return yaml.safe_load(f)
    return {}
```

## Advanced Features

### 1. Multi-Language Support

```python
def generate_multilingual_navbar(self, structure_data: Dict[str, Any]) -> Dict[str, Any]:
    """Generate navbar with language support."""
    
    languages = self.detect_languages(structure_data)
    
    if len(languages) > 1:
        # Add language switcher
        navbar['right'].insert(0, {
            'text': 'ðŸŒ Language',
            'menu': [
                {'text': f'English', 'href': f'/en/'},
                {'text': f'EspaÃ±ol', 'href': f'/es/'},
                # Add more languages as detected
            ]
        })
    
    return navbar
```

### 2. Theme Integration

```python
def apply_institutional_theme(self, base_path: Path) -> None:
    """Apply custom institutional theme."""
    
    # Generate custom CSS
    theme_css = f"""
    :root {{
        --institution-primary: {self.config['colors']['primary']};
        --institution-secondary: {self.config['colors']['secondary']};
        --institution-accent: {self.config['colors']['accent']};
    }}
    
    .navbar-brand::before {{
        content: "{self.config['institution']['logo']}";
        margin-right: 0.5rem;
    }}
    """
    
    # Write to custom theme file
    theme_file = base_path / 'quarto_code' / 'styles' / 'themes' / 'institutional.css'
    with open(theme_file, 'w') as f:
        f.write(theme_css)
```

### 3. Analytics Integration

```python
def add_analytics_tracking(self, structure_data: Dict[str, Any]) -> None:
    """Add analytics tracking to all content."""
    
    analytics_config = {
        'google_analytics': self.config.get('analytics', {}).get('ga_id'),
        'institutional_analytics': self.config.get('analytics', {}).get('inst_id')
    }
    
    # Update _quarto.yml with analytics
    self.update_analytics_config(analytics_config)
```

## Testing & Quality Assurance

### Unit Testing

Create `tests/test_your_script.py`:

```python
import pytest
from pathlib import Path
from unittest.mock import Mock, patch

from uumami.quarto_code.scripts.your_script import YourCustomAutomation

class TestYourCustomAutomation:
    
    def setup_method(self):
        self.base_path = Path("test_data")
        self.automation = YourCustomAutomation(self.base_path)
    
    def test_process_content_success(self):
        # Mock structure data
        structure_data = {
            'chapters': [{'name': 'test_chapter', 'title': 'Test'}],
            'appendices': [],
            'stats': {'total_chapters': 1}
        }
        
        result = self.automation.process_content(structure_data)
        assert result is True
    
    def test_process_content_with_empty_structure(self):
        structure_data = {'chapters': [], 'appendices': [], 'stats': {}}
        result = self.automation.process_content(structure_data)
        
        # Define expected behavior for empty structure
        assert result is True  # or False, depending on your logic
```

### Integration Testing

```bash
#!/bin/bash
# Integration test script

echo "ðŸ§ª Running integration tests..."

# Create test content structure
mkdir -p test_uumami/notas/00_test
echo "---\ntitle: Test Chapter\n---\n# Test" > test_uumami/notas/00_test/00_index.qmd

# Test discovery
python3 uumami/quarto_code/scripts/scan_structure.py test_uumami/ --validate

# Test validation
python3 uumami/quarto_code/scripts/validate_structure.py test_uumami/

# Test your custom script
python3 uumami/quarto_code/scripts/your_script.py test_uumami/ --dry-run

# Cleanup
rm -rf test_uumami/

echo "âœ… Integration tests completed"
```

## Deployment Considerations

### Production Readiness

**Checklist for Custom Scripts**:
- [ ] **Error Handling**: Comprehensive try/catch blocks
- [ ] **Input Validation**: Verify all inputs before processing
- [ ] **Backup Systems**: Create backups before destructive operations
- [ ] **Logging**: Detailed logging for troubleshooting
- [ ] **Documentation**: User and developer documentation
- [ ] **Testing**: Unit and integration tests
- [ ] **Performance**: Optimized for large content structures

### Maintenance Guidelines

**Version Control**:
```bash
# Tag releases for custom enhancements
git tag -a v2.4.0-custom -m "Custom institutional features v2.4.0"
git push origin v2.4.0-custom
```

**Update Procedures**:
1. **Test custom features** with new base system versions
2. **Update documentation** for any API changes
3. **Maintain backward compatibility** where possible
4. **Document breaking changes** clearly

---

**ðŸŽ¯ Ready to build?** Start with small extensions and gradually add more sophisticated features. The modular architecture makes it easy to add functionality without breaking existing systems.

**Need help?** Check existing scripts for patterns and implementation examples, or refer to the [Architecture Guide](02_architecture.qmd) for system design details. 