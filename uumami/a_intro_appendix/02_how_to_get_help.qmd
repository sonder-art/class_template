---
title: "Step 2: The Most Important Skill - Thinking with AI"
format:
  html:
    css:
      - ../styles/main.css
      - ../styles/themes/evangelion.css
---

## Your New Superpower: AI as a Thinking Partner

The single most important skill you will develop in this course is not coding; it's learning how to **think and solve problems in collaboration with AI**. In the past, you might have been stuck on a problem for hours. Today, you have a team of expert assistants available 24/7.

This guide will teach you how to use them for **everything**: from brainstorming and planning to writing, explaining, and debugging code. Your AI assistants (Gemini, Claude, Cursor's built-in AI, etc.) are your co-pilots. Learn to rely on them.

## Level 1: The Core Workflow

All effective interactions with an AI follow a simple pattern: **Plan -> Execute -> Refine**.

### Step 1: Plan and Design First (The "Zero-Code" Prompt)
Before you write a single line of code, you must know what you want to build. A common mistake is to ask the AI to "just build a website that does X." This rarely works well. Instead, ask the AI to be your co-planner.

-   **Goal:** Have the AI help you think through the problem and create a detailed plan.
-   **Prompt Example:**
    > You are an expert software architect. I need to build a simple command-line program that acts as a timer.
    >
    > Before we write any code, let's design it. Please help me by:
    > 1.  Listing the key features the timer should have.
    > 2.  Describing the main functions we will need to write.
    > 3.  Suggesting the best Python library to use for handling time.
    >
    > Please present the output in a markdown table for clarity.

### Step 2: Execute (Generate Code from the Plan)
Once you have a plan you like, you can ask the AI to generate the code for it. You can do this piece by piece.

-   **Goal:** Turn your agreed-upon design into functional code.
-   **Prompt Example (a follow-up to the previous prompt):**
    > That plan looks great. Now, please write the Python code for the `start_timer` function we designed. Please include detailed comments explaining how it works.

### Step 3: Refine and Explain
The first version of the code might not be perfect, or you might not understand it completely. Now you can iterate.

-   **Goal:** Clarify your understanding and improve the code.
-   **Prompt Example:**
    > This code works, but can you explain the line `import time`? What is that library and why do we need it? Also, can you refactor the code to add a sound that plays when the timer is done?

## Level 2: Advanced Prompting Techniques

To get truly high-quality results, you can use more advanced strategies.

### Technique 1: Persona Crafting
Telling the AI "You are a..." is the most powerful thing you can do. It forces the AI to adopt a specific knowledge base and communication style. Be specific!

-   **Bad:** "Explain this code."
-   **Good:** "You are a **cybersecurity expert**. Review this Python code and explain any potential security vulnerabilities."
-   **Excellent:** "You are a **data visualization designer** with expertise in creating clear, compelling charts for a non-technical audience. I have a dataset of monthly sales figures. Suggest three different types of charts I could make with `matplotlib` and explain the pros and cons of each for showing this data."

### Technique 2: Chain-of-Thought
Large language models work better when they think step-by-step. You can force this behavior by adding a simple phrase to your prompt.

-   **Prompt Example:**
    > I have a bug in my code. When I run it, I expect it to print "Hello, World!" but it prints "Hello, world!".
    > ```python
    > my_string = "hello, world!"
    > print(my_string.capitalize())
    > ```
    > Why is this happening? **Think step-by-step before you give me the answer.**

This forces the AI to trace the logic (`.capitalize()` only affects the first character) and give you a much better explanation.

### Technique 3: Self-Critique (The "Red Team" Prompt)
AIs will confidently give you wrong answers. A powerful technique is to ask the AI to challenge its own output.

-   **Prompt Example (after the AI has given you some code):**
    > Thank you. Now, please act as a skeptical senior developer. **Critique the code you just wrote.** Are there any hidden bugs, edge cases I haven't considered, or ways to make it more efficient?

This often reveals limitations or errors that you wouldn't have caught otherwise.

## The AI Collaboration Flow

The entire process of planning, coding, and refining can be visualized in the following flowchart. Refer back to this diagram to orient yourself whenever you're unsure what the next step should be.

```{mermaid}
graph TD
    %% Define Node Styles
    style Start fill:#E3F2FD,stroke:#90CAF9,stroke-width:2px,color:#000
    style PlanNode fill:#F3E5F5,stroke:#CE93D8,stroke-width:1px,color:#000
    style CodeNode fill:#E8F5E9,stroke:#A5D6A7,stroke-width:1px,color:#000
    style DebugNode fill:#FFFDE7,stroke:#FFD700,stroke-width:1px,color:#000
    style Decision fill:#FFCDD2,stroke:#E57373,stroke-width:1px,color:#000
    style Human fill:#FFAB91,stroke:#FF7043,stroke-width:2px,color:#000

    subgraph Phase 1: Planning & Design
        direction LR
        A(Start with<br>Idea/Problem) --> B(Engage AI as<br>Architect/Planner);
        B --> C(Prompt: 'Help me design a solution...<br>List features, functions, etc.');
        C --> D(AI Provides<br>Detailed Plan);
        D --> E{Is the plan<br>good & complete?};
        E -- No, Refine --> C;
    end

    subgraph Phase 2: Implementation & Refinement
        E -- Yes, Proceed --> G(Engage AI as<br>Programmer/Tutor);
        G --> H(Prompt: 'Based on the plan,<br>write code for Function Y');
        H --> I(AI Generates Code);
        I --> J{Review & Test Code};
        J -- "It works, but..." --> K{What's next?};
        K -- "Explain this code" --> L(Prompt: 'Explain concept X<br>or this block of code.');
        L --> G;
        K -- "Improve this code" --> M(Prompt: 'Critique this code.<br>How can it be better?');
        M --> G;
    end

    subgraph Phase 3: Debugging
        J -- "It has a bug!" --> P(Engage AI as<br>Detective);
        P --> Q(Prompt with Full Context:<br>Goal, Code, FULL Error Message);
        Q --> R(AI Suggests Fix);
        R --> S{Try Fix.<br>Does it work?};
        S -- "Yes, Fixed!" --> J;
        S -- "No, New Error" --> Q;
        S -- "Still Stuck!" --> T(Ask a Human);
    end

    %% Apply styles
    class A,G,P Start;
    class B,C,D,L,M PlanNode;
    class H,I CodeNode;
    class E,J,K,S Decision;
    class Q,R DebugNode;
    class T Human;
```

## When Things Go Wrong: The Debugging Workflow

Debugging is just a specific application of the core workflow, as shown in the "Debugging Sub-Loop" in the diagram above.

1.  **Plan:** Your "plan" is to understand the error. Use Perplexity or Google first with the error message as your query.
2.  **Execute:** If a search fails, ask your AI assistant. Provide the full context: your goal, the code, and the **full, exact error message**.
3.  **Refine:** If the AI's first suggestion doesn't work, tell it! "I tried your suggestion, but now I'm getting a *new* error. Here is the new error and my updated code."

### The Final Step: Ask a Human
If you have genuinely tried these steps and are still stuck, ask your peers or the instructor. When you do, provide the same context you would give an AI. This shows you've done your homework and helps them help you faster.

{{< include _nav.qmd >}}