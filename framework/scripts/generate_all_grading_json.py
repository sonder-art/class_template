#!/usr/bin/env python3
"""
Generate All Grading JSON Files
Combines modules.yml, constituents.yml, and parsed items into JSON files for frontend sync
"""

import os
import yaml
import json
import hashlib
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any
from rich.console import Console


class GradingJSONGenerator:
    """Generates all grading JSON files from YAML sources"""
    
    def __init__(self, project_root: Path, console: Console = None):
        self.project_root = Path(project_root)
        self.console = console or Console()
        self.class_template_dir = self.project_root / "class_template"
        self.hugo_data_dir = self.project_root / "hugo_generated" / "data"
        
    def generate_all_json(self) -> bool:
        """Generate all grading JSON files for frontend consumption"""
        
        self.console.print("üîß [bold]Generating All Grading JSON Files[/bold]")
        
        try:
            # Ensure output directory exists
            self.hugo_data_dir.mkdir(parents=True, exist_ok=True)
            
            # Generate individual JSON files
            if not self._generate_modules_json():
                return False
                
            if not self._generate_constituents_json():
                return False
                
            # Items JSON is already generated by parse_items.py
            # Just ensure it exists
            items_file = self.hugo_data_dir / "items.json"
            if not items_file.exists():
                self.console.print("‚ö†Ô∏è  items.json not found - run parse_items.py first")
                # Create empty items file as fallback
                with open(items_file, 'w') as f:
                    json.dump({
                        'generated_at': datetime.now().isoformat(),
                        'total_items': 0,
                        'items': []
                    }, f, indent=2)
            
            # Generate combined grading data file
            if not self._generate_combined_json():
                return False
                
            self.console.print("‚úÖ [bold green]All grading JSON files generated successfully[/bold green]")
            return True
            
        except Exception as e:
            self.console.print(f"‚ùå Error generating grading JSON: {e}")
            return False
    
    def _generate_modules_json(self) -> bool:
        """Generate modules.json from modules.yml"""
        
        modules_yml = self.class_template_dir / "modules.yml"
        if not modules_yml.exists():
            self.console.print(f"‚ö†Ô∏è  modules.yml not found: {modules_yml}")
            # Create empty modules file
            modules_data = {'modules': []}
        else:
            with open(modules_yml, 'r') as f:
                modules_data = yaml.safe_load(f)
        
        # Convert to list format for frontend
        modules_list = []
        for module_key, module_info in modules_data.get('modules', {}).items():
            modules_list.append({
                'id': module_info['id'],
                'name': module_info['name'],
                'description': module_info['description'],
                'weight': module_info['weight'],
                'order_index': module_info['order'],
                'color': module_info['color'],
                'icon': module_info['icon']
            })
        
        output = {
            'generated_at': datetime.now().isoformat(),
            'source_file': 'class_template/modules.yml',
            'total_modules': len(modules_list),
            'modules': modules_list
        }
        
        output_file = self.hugo_data_dir / "modules.json"
        with open(output_file, 'w') as f:
            json.dump(output, f, indent=2)
        
        self.console.print(f"‚úÖ Generated modules.json: {len(modules_list)} modules")
        return True
    
    def _generate_constituents_json(self) -> bool:
        """Generate constituents.json from constituents.yml"""
        
        constituents_yml = self.class_template_dir / "constituents.yml"
        if not constituents_yml.exists():
            self.console.print(f"‚ö†Ô∏è  constituents.yml not found: {constituents_yml}")
            # Create empty constituents file
            constituents_data = {'constituents': []}
        else:
            with open(constituents_yml, 'r') as f:
                constituents_data = yaml.safe_load(f)
        
        # Convert to list format for frontend
        constituents_list = []
        for const_key, const_info in constituents_data.get('constituents', {}).items():
            constituents_list.append({
                'id': const_info['id'],
                'slug': const_info['slug'],
                'name': const_info['name'],
                'description': const_info['description'],
                'module_id': const_info['module_id'],
                'weight': const_info['weight'],
                'type': const_info['type'],
                'max_attempts': const_info['max_attempts']
            })
        
        output = {
            'generated_at': datetime.now().isoformat(),
            'source_file': 'class_template/constituents.yml',
            'total_constituents': len(constituents_list),
            'constituents': constituents_list
        }
        
        output_file = self.hugo_data_dir / "constituents.json"
        with open(output_file, 'w') as f:
            json.dump(output, f, indent=2)
        
        self.console.print(f"‚úÖ Generated constituents.json: {len(constituents_list)} constituents")
        return True
    
    def _generate_combined_json(self) -> bool:
        """Generate combined grading data with checksums for sync detection"""
        
        # Load all individual JSON files
        modules_file = self.hugo_data_dir / "modules.json"
        constituents_file = self.hugo_data_dir / "constituents.json"
        items_file = self.hugo_data_dir / "items.json"
        
        modules_data = json.loads(modules_file.read_text()) if modules_file.exists() else {'modules': []}
        constituents_data = json.loads(constituents_file.read_text()) if constituents_file.exists() else {'constituents': []}
        items_data = json.loads(items_file.read_text()) if items_file.exists() else {'items': []}
        
        # Generate checksums for change detection
        modules_str = json.dumps(modules_data['modules'], sort_keys=True)
        constituents_str = json.dumps(constituents_data['constituents'], sort_keys=True)
        items_str = json.dumps(items_data['items'], sort_keys=True)
        
        checksums = {
            'modules': hashlib.sha256(modules_str.encode()).hexdigest()[:16],
            'constituents': hashlib.sha256(constituents_str.encode()).hexdigest()[:16],
            'items': hashlib.sha256(items_str.encode()).hexdigest()[:16]
        }
        
        # Get class_id from course.yml
        course_file = self.class_template_dir / "course.yml"
        class_id = None
        if course_file.exists():
            with open(course_file, 'r') as f:
                course_data = yaml.safe_load(f)
            class_id = course_data.get('class_id')
        
        # Combined output
        combined = {
            'generated_at': datetime.now().isoformat(),
            'class_id': class_id,
            'checksums': checksums,
            'counts': {
                'modules': len(modules_data['modules']),
                'constituents': len(constituents_data['constituents']),
                'items': len(items_data['items'])
            },
            'data': {
                'modules': modules_data['modules'],
                'constituents': constituents_data['constituents'],
                'items': items_data['items']
            },
            'sources': {
                'modules': modules_data.get('source_file', 'class_template/modules.yml'),
                'constituents': constituents_data.get('source_file', 'class_template/constituents.yml'),
                'items': items_data.get('total_files', 0)
            }
        }
        
        output_file = self.hugo_data_dir / "grading_complete.json"
        with open(output_file, 'w') as f:
            json.dump(combined, f, indent=2)
        
        self.console.print(f"‚úÖ Generated grading_complete.json with checksums")
        self.console.print(f"   üìä {combined['counts']['modules']} modules, {combined['counts']['constituents']} constituents, {combined['counts']['items']} items")
        return True


def main():
    """Main function for standalone execution"""
    console = Console()
    
    # Determine project root
    project_root = Path.cwd()
    if project_root.name in ['professor', 'students']:
        project_root = project_root.parent
    
    console.print(f"üöÄ [bold]Grading JSON Generator[/bold]")
    console.print(f"Project root: {project_root}")
    
    # Create generator and run
    generator = GradingJSONGenerator(project_root, console)
    success = generator.generate_all_json()
    
    if success:
        console.print("\\n‚úÖ [bold green]All grading JSON files generated successfully[/bold green]")
        return 0
    else:
        console.print("\\n‚ùå [bold red]Grading JSON generation failed[/bold red]")
        return 1


if __name__ == "__main__":
    exit(main())